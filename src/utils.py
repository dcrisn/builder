#!/usr/bin/python3

"""
Helper functions
"""
import os
import sys
import shutil
import pathlib
import json
import jsonschema
import subprocess
import tarfile
import tempfile
import re

STREAM_LOGGING_ON = False
FILE_LOGGING_ON   = False
LOGFILE           = ".tmp/build.log"

def set_logging(tostdout=False, tofile=False):
    global STREAM_LOGGING_ON, FILE_LOGGING_ON
    STREAM_LOGGING_ON = tostdout
    FILE_LOGGING_ON   = tofile

def strip_sgr(s):
    """ Strip ANSI SGR sequences from string and return it """
    pattern = r'(?:\x1B[@-Z\\-_]|[\x80-\x9A\x9C-\x9F]|(?:\x1B\[|\x9B)[0-?]*[ -/]*[@-~])'
    return re.sub(pattern, '', s)

def strip_quoted_newlines(s):
    if not s:
        return s
    if s[-1] == "'" or s[-1] == '"':
        s = s[:-1]
    return s.rstrip()

def log(msg, cond=None):
    condition = cond
    if condition != None and not condition:
        return
    # turn off any stray ANSI SGR effects
    msg = strip_sgr(msg)
    # strip sneaky newlines followed by single quotes, evading .rstrip()
    msg = strip_quoted_newlines(msg)
    if STREAM_LOGGING_ON:
        print(msg, flush=True)
    if FILE_LOGGING_ON:
        with open(LOGFILE, "a") as f:
            f.write(msg + '\n')

def dedup(s, c, keep_last=True):
    append = s[-1] if (keep_last and s[-1] == c) else ''
    parts = [x for x in s.split(c) if x]
    return c.join(parts) + append

def get_last_path_component(path):
    if not path:
        raise ValueError("NULL string provided where non-NULL expected")
    if path == '/':
        return path
    last = [x for x in dedup(path, '/').split('/') if x][-1]
    return last + (path[-1] == '/' and '/' or '')

def ensure_dir_semantics(path):
    """
    Append a trailing forward slash to path if path[1] != '/'
    """
    return path + ('/' if path[-1] != '/' else '')

def get_project_root():
    cwd = os.path.dirname(os.path.realpath(__file__)) + '/'
    root = os.path.abspath(f"{cwd}/..")
    # project root must have the .git directory
    return root

def cp_dir(src_dir, dst_dir, empty_first=False, just_contents=False):
    """
    cp the directory a to inside b. The whole directory is copied,
    not just the contents.
    All the path components are created if they
    do not exist.
    """
    dst = dst_dir
    if not just_contents:
        dst = dst_dir + "/" + get_last_path_component(src_dir)
    if os.path.exists(dst):
        if os.path.isdir(dst) and empty_first:
            shutil.rmtree(dst)
        elif os.path.isfile(dst):
            raise NotADirectoryError("Source directory is a file!")
    os.makedirs(dst, exist_ok=True)
    shutil.copytree(src_dir, dst, dirs_exist_ok=True)

def cp_file(src_file, dst_dir, dst_fname=None, make_dirs=True, must_exist=False):
    if not os.path.isfile(src_file):
        if must_exist:
            raise FileNotFoundError
        return
    if make_dirs:
        os.makedirs(dst_dir, exist_ok=True)
    shutil.copy2(src_file, dst_dir + "/" + (dst_fname or ''))

def load_json_from_file(path):
    with open(path, "r", encoding='utf8') as fh:
        return json.load(fh)

def validate_json_against_schema(instancefile, schemas_dir):
    instance     = load_json_from_file(instancefile)
    schemafile   = schemas_dir + f"{instance['schema']}"
    schema       = load_json_from_file(schemafile)

    # add trailing slash, see
    # https://python-jsonschema.readthedocs.io/en/stable/faq/#how-do-i-configure-a-base-uri-for-ref-resolution-using-local-files
    schemas_path = pathlib.Path(schemas_dir).absolute().as_uri() + '/'

    relref_resolver = jsonschema.validators.RefResolver(base_uri=schemas_path, referrer=True)

    try:
        jsonschema.validate(instance, schema, resolver=relref_resolver)
    except jsonschema.exceptions.ValidationError as e :
        print(f"Instance {instancefile} is invalid against schema {schemafile}")
        raise
    except jsonschema.exceptions.SchemaError as e:
        print(f"Failed to validate {instancefile} -- invalid schema('{schemafile}')")
        raise
    else:
        return instance

def run(cmd, env=None, capture=False, timeout=None):
    """
    Run cmd in subshell with the specified environment.

    :param cmd:       command to run in a subshell.
    :param env:       the environment to execute cmd with. If not specified,
                      the environment is inherited from the parent shell.
    :param capture:   whether to capture the stdout and stderr streams of the subprocess.
                      If False, instead of capturing, any output generated by the subprocess
                      is printed to stdout.
    :param timeout:   The longest time in milliseconds to wait for the subprocess to complete before
                      forceful termination. If None, the subprocess will be waited for indefinitely.

    :return:          A (<return code>, <output>) tuple if capture=True, else 
                      a (<return code>, None) tuple.
    """
    proc_completed = None
    try:
        proc_completed = subprocess.run(
                cmd,
                text=True,
                timeout=timeout,
                check=True,
                shell=True,
                stdout = subprocess.PIPE if capture else sys.stdout,
                stderr = subprocess.STDOUT,
                env=env
                )
    except subprocess.CalledProcessError as e:
        print(f"e is {e}")
        if capture:
            output = e.stdout.strip()
            print(f' !! Command "{cmd}" failed with error code {e.returncode}: \n<<{output}>>')
        else:
            print(f' !! Command "{cmd}" failed with error code {e.returncode}.')
        raise
    else:
        return (proc_completed.returncode, proc_completed.stdout)

def interact(cmd, env=None, timeout=None):
    # note you DO NOT want to have the communication with the child proxied
    # via pipes. Docker will complain the driving program is not a tty. Instead,
    # simply interact with the program by connecting it directly to the standard streams.
    try:
        proc_completed = subprocess.run(
                cmd,
                text=True,
                timeout=timeout,
                check=True,
                shell=True,
                stdout = sys.stdout,
                stderr = sys.stderr,
                stdin  = sys.stdin,
                env=env
                )
    except subprocess.CalledProcessError as e:
        print(f'WARNING: Positive exit status code ({e.returncode}).')

def run_commands(cmds, env=None, cb=None, verbose=True):
    for cmd in cmds:
        # in verbose mode, write to stdout; else inhibit by capturing.
        r = run(cmd, env, capture=not verbose)
        if cb:
            cb(r)

def is_executable(file):
    return os.path.isfile(file) and os.access(file, os.X_OK)

def has_scripts(path):
    for file in os.listdir(path):
        if is_executable(path + '/' + file):
            return True
    return False

def is_hidden_file(filename):
    if filename[0] == '.':
        return True

def get_sorted_script_list(path):
    scripts = []
    for file in os.listdir(path):
        if is_hidden_file(file):
            continue
        if is_executable(path + '/' + file):
            prio = int(file.split('.')[0])
            scripts.append( (prio, path + "/" + file) )
    return [x[1] for x in sorted(scripts)]

def append_to_tarball(tarpath, *args, prefix=''):
    temp_dir = tempfile.mkdtemp() + '/'
    #print("temp_dir is ", temp_dir)
    tar = tarfile.open(tarpath, 'r')
    tar.extractall(path=temp_dir)
    
    for item in args:
        shutil.copy2(item, temp_dir + prefix)

    os.remove(tarpath)
    tar = tarfile.open(tarpath, 'a')
    os.chdir(temp_dir)
    tar.add('.')
    tar.close()
    shutil.rmtree(temp_dir)

def get_attr_if_exists(modname, attrname):
    module    = sys.modules.get(modname)
    if not module:
        raise LookupError("Cannot get attribute '{classname}' from unknown module '{modname}'")
    if hasattr(module, attrname):
        return getattr(module, attrname)
    return None

def validate_mounts(mounts):
    """
    Ensure the source (host) paths actually exist.
    :param mounts : list of mount triples
    """
    for mount in mounts:
        srcpath = mount[0]
        if not os.path.exists(srcpath):
            raise FileNotFoundError(f"Cannot mount {srcpath} from the host: no such file or directory")
        if not os.path.isdir(srcpath):
            raise NotADirectoryError(f"Cannot mount {srcpath} from the host: not a directory")
    return mounts

def print_dirtree(startpath):
    def walk_dir(current_path, prefix=""):
        entries = sorted(os.listdir(current_path))
        entries = [e for e in entries if not e.startswith('.')]  # optional: skip hidden
        entries_count = len(entries)

        for idx, entry in enumerate(entries):
            path = os.path.join(current_path, entry)
            connector = "└── " if idx == entries_count - 1 else "├── "
            print(prefix + connector + entry)

            if os.path.isdir(path):
                extension = "    " if idx == entries_count - 1 else "│   "
                walk_dir(path, prefix + extension)

    print(startpath)
    walk_dir(startpath)

def make_file(path):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    if os.path.exists(path): return
    with open(path, 'w') as f:
        pass


